[[routing]]
= Routing

== RoutingFlux

The routing flux connects a source stream to downstream subscribers by providing a way to efficient filter interesting
 values while keeping reactive stream semantics.

The routing decision is based on a key that is calculated once for each source value in the stream. This key is
passed to a function that selects the downstream subscribers which should receive the source value. Since the
base `RoutingFlux` class doesn't decide how routing is implemented, it can be used as a building block
for creating routers for different type of use cases.

=== Differentiators

==== How is a routing flux different than sharing a source flux and filtering each downstream flux with a predicate function?

In the initial version, the difference is subtle when using a `PredicateRoutingFlux`.
The main differentiator in using a `PredicateRoutingFlux` would be the future features to be added to
handle <<backpressure-in-routing,backpressure>> in the routing scenario.
Since the base `RoutingFlux` isn't tied to predicate based filtering, it's extendable to lookup table based routing.
The `KeyedRoutingFlux` is an example of lookup table based routing.

=== Design problems

==== Non-scalable solution when the routing decision uses a per-subscriber predicate function for filtering values

When the routing decision is based on a predicate function, the function has to be evaluated once for every
downstream subscriber, for every value in the stream.
To make the basic routing building block scalable, it should provide a way to implement key-based routing with a lookup
table.


[[backpressure-in-routing]]
==== Backpressure in a single downstream subscriber stops the stream

Currently when any downstream subscriber gets backpressured, it will stop the `RoutingFlux` stream 
and no values get emitted to any downstream subscriber. This is a safe default, but might be a problem 
for some use cases and could be confusing from the developer's perspective if there's not solutions for easily 
configuring backpressure dropping in these cases. Currently every downstream would have to contain a separate 
operator for dropping values on backpressure to be able to configure this. The alternative would be to support
configuring backpressure on the emitting side. It's a fairly easy change to `RoutingFlux` to handle this, but 
is it adding unnecessary complexity?

=== API examples

`PredicateRoutingFlux` example
[source,java]
----
PredicateRoutingFlux<Integer, Integer> routingFlux = PredicateRoutingFlux.create(Flux.range(1, 5),
        QueueSupplier.SMALL_BUFFER_SIZE, QueueSupplier.get(QueueSupplier.SMALL_BUFFER_SIZE), 
        Function.identity());

Flux<Integer> evenFlux = routingFlux.route(x -> x % 2 == 0);
Flux<Integer> oddFlux = routingFlux.route(x -> x % 2 != 0);

routingFlux.connect();

Mono<List<Integer>> evenListMono = evenFlux.collectList().subscribe();
Mono<List<Integer>> oddListMono = oddFlux.collectList().subscribe();

assertEquals(Arrays.asList(2, 4), evenListMono.block());
assertEquals(Arrays.asList(1, 3, 5), oddListMono.block());
----

`KeyedRoutingFlux` example
[source,java]
----
KeyedRoutingFlux<Integer, Integer> routingFlux = KeyedRoutingFlux.create(Flux.range(1, 5),
        QueueSupplier.SMALL_BUFFER_SIZE, QueueSupplier.get(QueueSupplier.SMALL_BUFFER_SIZE), 
        value -> value % 2);

Flux<Integer> evenFlux = routingFlux.route(0);
Flux<Integer> oddFlux = routingFlux.route(1);

routingFlux.connect();

Mono<List<Integer>> evenListMono = evenFlux.collectList().subscribe();
Mono<List<Integer>> oddListMono = oddFlux.collectList().subscribe();

assertEquals(Arrays.asList(2, 4), evenListMono.block());
assertEquals(Arrays.asList(1, 3, 5), oddListMono.block());
----
